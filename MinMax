from random import randint

class Game:
    def __init__(self, length: int):
        self.points = [0, 0]
        length = max(min(length, 20), 15)
        self.numbers = [randint(1, 4) for i in range(length)]
        self.player = 0  # 0 is p1, 1 is p2

    def __str__(self):
        return f"""
Punkti: {self.points}, Gājiens: {self.player+1}. spēlētājam
Skaitļi (indekss, skaitlis): {list(enumerate(self.numbers))}
        """

    def turn(self, mode: bool, ind: int):
        # False is take, True is split
        if mode:
            self.points[self.player] += self.numbers[ind]
            self.numbers.pop(ind)
        else:
            if self.numbers[ind] % 2 == 1:
                print("nevar sadalīt")
            else:
                self.numbers[ind] //= 2
                self.numbers.insert(ind, self.numbers[ind])
                self.points[self.player] += self.numbers[ind] // 2
        self.player = (self.player + 1) % 2

    def available_moves(self):
        return [(True, i) for i in range(len(self.numbers))] + [(False, i) for i in range(len(self.numbers)) if self.numbers[i] % 2 == 0]

    def copy(self):
        copied_game = Game(0)
        copied_game.points = self.points.copy()
        copied_game.numbers = self.numbers.copy()
        copied_game.player = self.player
        return copied_game

    def evaluate(self):
        return self.points[1] - self.points[0]  # Computer is maximizing, human is minimizing

def mini_max(game, depth, maximizing_player):
    if depth == 0 or len(game.numbers) == 0:
        return game.evaluate()

    if maximizing_player:
        max_eval = float('-inf')
        for move in game.available_moves():
            new_game = game.copy()
            new_game.turn(*move)
            eval = mini_max(new_game, depth - 1, False)
            max_eval = max(max_eval, eval)
        return max_eval
    else:
        min_eval = float('inf')
        for move in game.available_moves():
            new_game = game.copy()
            new_game.turn(*move)
            eval = mini_max(new_game, depth - 1, True)
            min_eval = min(min_eval, eval)
        return min_eval

def computer_move(game):
    best_eval = float('-inf')
    best_move = None
    for move in game.available_moves():
        new_game = game.copy()
        new_game.turn(*move)
        eval = mini_max(new_game, 3, False)  # Adjust depth as needed
        if eval > best_eval:
            best_eval = eval
            best_move = move
    return best_move

def main():
    sequence_length = int(input("Ievadi cik skaitļus ģenerēt: "))
    game = Game(sequence_length)

    while len(game.numbers) > 0:
        print(game)
        if game.player == 0:  # Human player
            command = input("(P)aņem vai (S)adali skaitli indeksā: ")
            mode = command[0].lower()
            ind = int(command[1:])
            game.turn(mode == "p", ind)
        else:  # Computer player
            move = computer_move(game)
            game.turn(*move)

    print(f"Spēle beidzās ar rezultātu {game.points}")

if __name__ == "__main__":
    main()
